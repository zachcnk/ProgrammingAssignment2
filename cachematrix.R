## makeCacheMatrix takes a matrix (assumed to be square) and returns an object containing 
## the matrix and getter and setter functions for the matrix and its inverse
## cacheSolve takes the object returned by makeCacheMatrix and gets its inverse, using the 
## cached value if available and saving the computed inverse to the cache if not

## makeCacheMatrix takes a matrix x and provides a cache for its inverse
## The cache is set to null whenever x is set, and both the matrix and its inverse
## can be retrieved and set with the included functions

makeCacheMatrix <- function(x = matrix()) {
  inv <- NULL ## Set matrix cached inverse to null
  set <- function(y) { ## Set matrix, and set inverse cache to null
    x <<- y
    inv <<- NULL
  }
  get <- function() x ## Retrieve matrix
  setinv <- function(invMat) inv <<- invMat ## Set cached inverse for future retrieval
  getinv <- function() inv ## Get cached inverse matrix, which may be null if it has not been computed
  list(set = set, get = get, setinv = setinv, getinv = getinv) ## Return object
}


## cacheSolve takes an object x (generated by makeCacheMatrix) and returns its inverse
## If x already has a cached inverse set (aka has been computed since the last time x had 
## its matrix set), cacheSolve simply returns the cached value. If not, it computes the 
## inverse using solve() and saves the inverse matrix using x$setinv as defined above

cacheSolve <- function(x, ...) {
  inv <- x$getinv() ## Retrieve the cached inverse
  if (!is.null(inv)) { ## If it's not null, return it
    message("Getting cached inverse")
    return(inv)
  }
  ## If the cached matrix was null, compute it from the original matrix
  message("Computing inverse")
  data <- x$get()
  inv <- solve(data)
  ## Store the inverse into the cache for future use, and return the inverse
  x$setinv(inv)
  inv
}
